{"code":"/**\r\n * To start using Traveler, require it in main.js:\r\n * Example: var Traveler = require('Traveler.js');\r\n */\r\n//@ts-nocheck\r\nexport class Traveler {\r\n    /**\r\n     * move creep to destination\r\n     * @param creep\r\n     * @param destination\r\n     * @param options\r\n     * @returns {number}\r\n     */\r\n    static travelTo(creep, destination, options = {}) {\r\n        // uncomment if you would like to register hostile rooms entered\r\n        // this.updateRoomStatus(creep.room);\r\n        if (!destination) {\r\n            return ERR_INVALID_ARGS;\r\n        }\r\n        if (creep.fatigue > 0) {\r\n            Traveler.circle(creep.pos, \"aqua\", .3);\r\n            return ERR_TIRED;\r\n        }\r\n        destination = this.normalizePos(destination);\r\n        // manage case where creep is nearby destination\r\n        let rangeToDestination = creep.pos.getRangeTo(destination);\r\n        if (options.range && rangeToDestination <= options.range) {\r\n            return OK;\r\n        }\r\n        else if (rangeToDestination <= 1) {\r\n            if (rangeToDestination === 1 && !options.range) {\r\n                let direction = creep.pos.getDirectionTo(destination);\r\n                if (options.returnData) {\r\n                    options.returnData.nextPos = destination;\r\n                    options.returnData.path = direction.toString();\r\n                }\r\n                return creep.move(direction);\r\n            }\r\n            return OK;\r\n        }\r\n        // initialize data object\r\n        if (!creep.memory._trav) {\r\n            delete creep.memory._travel;\r\n            creep.memory._trav = {};\r\n        }\r\n        let travelData = creep.memory._trav;\r\n        let state = this.deserializeState(travelData, destination);\r\n        // uncomment to visualize destination\r\n        // this.circle(destination.pos, \"orange\");\r\n        // check if creep is stuck\r\n        if (this.isStuck(creep, state)) {\r\n            state.stuckCount++;\r\n            Traveler.circle(creep.pos, \"magenta\", state.stuckCount * .2);\r\n        }\r\n        else {\r\n            state.stuckCount = 0;\r\n        }\r\n        // handle case where creep is stuck\r\n        if (!options.stuckValue) {\r\n            options.stuckValue = DEFAULT_STUCK_VALUE;\r\n        }\r\n        if (state.stuckCount >= options.stuckValue && Math.random() > .5) {\r\n            options.ignoreCreeps = false;\r\n            options.freshMatrix = true;\r\n            delete travelData.path;\r\n        }\r\n        // TODO:handle case where creep moved by some other function, but destination is still the same\r\n        // delete path cache if destination is different\r\n        if (!this.samePos(state.destination, destination)) {\r\n            if (options.movingTarget && state.destination.isNearTo(destination)) {\r\n                travelData.path += state.destination.getDirectionTo(destination);\r\n                state.destination = destination;\r\n            }\r\n            else {\r\n                delete travelData.path;\r\n            }\r\n        }\r\n        if (options.repath && Math.random() < options.repath) {\r\n            // add some chance that you will find a new path randomly\r\n            delete travelData.path;\r\n        }\r\n        // pathfinding\r\n        let newPath = false;\r\n        if (!travelData.path) {\r\n            newPath = true;\r\n            if (creep.spawning) {\r\n                return ERR_BUSY;\r\n            }\r\n            state.destination = destination;\r\n            let cpu = Game.cpu.getUsed();\r\n            let ret = this.findTravelPath(creep.pos, destination, options);\r\n            let cpuUsed = Game.cpu.getUsed() - cpu;\r\n            state.cpu = _.round(cpuUsed + state.cpu);\r\n            if (state.cpu > REPORT_CPU_THRESHOLD) {\r\n                // see note at end of file for more info on this\r\n                console.log(`TRAVELER: heavy cpu use: ${creep.name}, cpu: ${state.cpu} origin: ${creep.pos}, dest: ${destination}`);\r\n            }\r\n            let color = \"orange\";\r\n            if (ret.incomplete) {\r\n                // uncommenting this is a great way to diagnose creep behavior issues\r\n                // console.log(`TRAVELER: incomplete path for ${creep.name}`);\r\n                color = \"red\";\r\n            }\r\n            if (options.returnData) {\r\n                options.returnData.pathfinderReturn = ret;\r\n            }\r\n            travelData.path = Traveler.serializePath(creep.pos, ret.path, color);\r\n            state.stuckCount = 0;\r\n        }\r\n        this.serializeState(creep, destination, state, travelData);\r\n        if (!travelData.path || travelData.path.length === 0) {\r\n            return ERR_NO_PATH;\r\n        }\r\n        // consume path\r\n        if (state.stuckCount === 0 && !newPath) {\r\n            travelData.path = travelData.path.substr(1);\r\n        }\r\n        let nextDirection = parseInt(travelData.path[0], 10);\r\n        if (options.returnData) {\r\n            if (nextDirection) {\r\n                let nextPos = Traveler.positionAtDirection(creep.pos, nextDirection);\r\n                if (nextPos) {\r\n                    options.returnData.nextPos = nextPos;\r\n                }\r\n            }\r\n            options.returnData.state = state;\r\n            options.returnData.path = travelData.path;\r\n        }\r\n        return creep.move(nextDirection);\r\n    }\r\n    /**\r\n     * make position objects consistent so that either can be used as an argument\r\n     * @param destination\r\n     * @returns {any}\r\n     */\r\n    static normalizePos(destination) {\r\n        if (!(destination instanceof RoomPosition)) {\r\n            return destination.pos;\r\n        }\r\n        return destination;\r\n    }\r\n    /**\r\n     * check if room should be avoided by findRoute algorithm\r\n     * @param roomName\r\n     * @returns {RoomMemory|number}\r\n     */\r\n    static checkAvoid(roomName) {\r\n        return Memory.rooms && Memory.rooms[roomName] && Memory.rooms[roomName].avoid;\r\n    }\r\n    /**\r\n     * check if a position is an exit\r\n     * @param pos\r\n     * @returns {boolean}\r\n     */\r\n    static isExit(pos) {\r\n        return pos.x === 0 || pos.y === 0 || pos.x === 49 || pos.y === 49;\r\n    }\r\n    /**\r\n     * check two coordinates match\r\n     * @param pos1\r\n     * @param pos2\r\n     * @returns {boolean}\r\n     */\r\n    static sameCoord(pos1, pos2) {\r\n        return pos1.x === pos2.x && pos1.y === pos2.y;\r\n    }\r\n    /**\r\n     * check if two positions match\r\n     * @param pos1\r\n     * @param pos2\r\n     * @returns {boolean}\r\n     */\r\n    static samePos(pos1, pos2) {\r\n        return this.sameCoord(pos1, pos2) && pos1.roomName === pos2.roomName;\r\n    }\r\n    /**\r\n     * draw a circle at position\r\n     * @param pos\r\n     * @param color\r\n     * @param opacity\r\n     */\r\n    static circle(pos, color, opacity) {\r\n        new RoomVisual(pos.roomName).circle(pos, {\r\n            radius: .45, fill: \"transparent\", stroke: color, strokeWidth: .15, opacity: opacity\r\n        });\r\n    }\r\n    /**\r\n     * update memory on whether a room should be avoided based on controller owner\r\n     * @param room\r\n     */\r\n    static updateRoomStatus(room) {\r\n        if (!room) {\r\n            return;\r\n        }\r\n        if (room.controller) {\r\n            if (room.controller.owner && !room.controller.my) {\r\n                room.memory.avoid = 1;\r\n            }\r\n            else {\r\n                delete room.memory.avoid;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * find a path from origin to destination\r\n     * @param origin\r\n     * @param destination\r\n     * @param options\r\n     * @returns {PathfinderReturn}\r\n     */\r\n    static findTravelPath(origin, destination, options = {}) {\r\n        _.defaults(options, {\r\n            ignoreCreeps: true,\r\n            maxOps: DEFAULT_MAXOPS,\r\n            range: 1,\r\n        });\r\n        if (options.movingTarget) {\r\n            options.range = 0;\r\n        }\r\n        origin = this.normalizePos(origin);\r\n        destination = this.normalizePos(destination);\r\n        let originRoomName = origin.roomName;\r\n        let destRoomName = destination.roomName;\r\n        // check to see whether findRoute should be used\r\n        let roomDistance = Game.map.getRoomLinearDistance(origin.roomName, destination.roomName);\r\n        let allowedRooms = options.route;\r\n        if (!allowedRooms && (options.useFindRoute || (options.useFindRoute === undefined && roomDistance > 2))) {\r\n            let route = this.findRoute(origin.roomName, destination.roomName, options);\r\n            if (route) {\r\n                allowedRooms = route;\r\n            }\r\n        }\r\n        let roomsSearched = 0;\r\n        let callback = (roomName) => {\r\n            if (allowedRooms) {\r\n                if (!allowedRooms[roomName]) {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (!options.allowHostile && Traveler.checkAvoid(roomName)\r\n                && roomName !== destRoomName && roomName !== originRoomName) {\r\n                return false;\r\n            }\r\n            roomsSearched++;\r\n            let matrix;\r\n            let room = Game.rooms[roomName];\r\n            if (room) {\r\n                if (options.ignoreStructures) {\r\n                    matrix = new PathFinder.CostMatrix();\r\n                    if (!options.ignoreCreeps) {\r\n                        Traveler.addCreepsToMatrix(room, matrix);\r\n                    }\r\n                }\r\n                else if (options.ignoreCreeps || roomName !== originRoomName) {\r\n                    matrix = this.getStructureMatrix(room, options.freshMatrix);\r\n                }\r\n                else {\r\n                    matrix = this.getCreepMatrix(room);\r\n                }\r\n                if (options.obstacles) {\r\n                    matrix = matrix.clone();\r\n                    for (let obstacle of options.obstacles) {\r\n                        if (obstacle.pos.roomName !== roomName) {\r\n                            continue;\r\n                        }\r\n                        matrix.set(obstacle.pos.x, obstacle.pos.y, 0xff);\r\n                    }\r\n                }\r\n            }\r\n            if (options.roomCallback) {\r\n                if (!matrix) {\r\n                    matrix = new PathFinder.CostMatrix();\r\n                }\r\n                let outcome = options.roomCallback(roomName, matrix.clone());\r\n                if (outcome !== undefined) {\r\n                    return outcome;\r\n                }\r\n            }\r\n            return matrix;\r\n        };\r\n        let ret = PathFinder.search(origin, { pos: destination, range: options.range }, {\r\n            maxOps: options.maxOps,\r\n            maxRooms: options.maxRooms,\r\n            plainCost: options.offRoad ? 1 : options.ignoreRoads ? 1 : 2,\r\n            swampCost: options.offRoad ? 1 : options.ignoreRoads ? 5 : 10,\r\n            roomCallback: callback,\r\n        });\r\n        if (ret.incomplete && options.ensurePath) {\r\n            if (options.useFindRoute === undefined) {\r\n                // handle case where pathfinder failed at a short distance due to not using findRoute\r\n                // can happen for situations where the creep would have to take an uncommonly indirect path\r\n                // options.allowedRooms and options.routeCallback can also be used to handle this situation\r\n                if (roomDistance <= 2) {\r\n                    console.log(`TRAVELER: path failed without findroute, trying with options.useFindRoute = true`);\r\n                    console.log(`from: ${origin}, destination: ${destination}`);\r\n                    options.useFindRoute = true;\r\n                    ret = this.findTravelPath(origin, destination, options);\r\n                    console.log(`TRAVELER: second attempt was ${ret.incomplete ? \"not \" : \"\"}successful`);\r\n                    return ret;\r\n                }\r\n                // TODO: handle case where a wall or some other obstacle is blocking the exit assumed by findRoute\r\n            }\r\n            else {\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    /**\r\n     * find a viable sequence of rooms that can be used to narrow down pathfinder's search algorithm\r\n     * @param origin\r\n     * @param destination\r\n     * @param options\r\n     * @returns {{}}\r\n     */\r\n    static findRoute(origin, destination, options = {}) {\r\n        let restrictDistance = options.restrictDistance || Game.map.getRoomLinearDistance(origin, destination) + 10;\r\n        let allowedRooms = { [origin]: true, [destination]: true };\r\n        let highwayBias = 1;\r\n        if (options.preferHighway) {\r\n            highwayBias = 2.5;\r\n            if (options.highwayBias) {\r\n                highwayBias = options.highwayBias;\r\n            }\r\n        }\r\n        let ret = Game.map.findRoute(origin, destination, {\r\n            routeCallback: (roomName) => {\r\n                if (options.routeCallback) {\r\n                    let outcome = options.routeCallback(roomName);\r\n                    if (outcome !== undefined) {\r\n                        return outcome;\r\n                    }\r\n                }\r\n                let rangeToRoom = Game.map.getRoomLinearDistance(origin, roomName);\r\n                if (rangeToRoom > restrictDistance) {\r\n                    // room is too far out of the way\r\n                    return Number.POSITIVE_INFINITY;\r\n                }\r\n                if (!options.allowHostile && Traveler.checkAvoid(roomName) &&\r\n                    roomName !== destination && roomName !== origin) {\r\n                    // room is marked as \"avoid\" in room memory\r\n                    return Number.POSITIVE_INFINITY;\r\n                }\r\n                let parsed;\r\n                if (options.preferHighway) {\r\n                    parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(roomName);\r\n                    let isHighway = (parsed[1] % 10 === 0) || (parsed[2] % 10 === 0);\r\n                    if (isHighway) {\r\n                        return 1;\r\n                    }\r\n                }\r\n                // SK rooms are avoided when there is no vision in the room, harvested-from SK rooms are allowed\r\n                if (!options.allowSK && !Game.rooms[roomName]) {\r\n                    if (!parsed) {\r\n                        parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(roomName);\r\n                    }\r\n                    let fMod = parsed[1] % 10;\r\n                    let sMod = parsed[2] % 10;\r\n                    let isSK = !(fMod === 5 && sMod === 5) &&\r\n                        ((fMod >= 4) && (fMod <= 6)) &&\r\n                        ((sMod >= 4) && (sMod <= 6));\r\n                    if (isSK) {\r\n                        return 10 * highwayBias;\r\n                    }\r\n                }\r\n                return highwayBias;\r\n            },\r\n        });\r\n        if (!_.isArray(ret)) {\r\n            console.log(`couldn't findRoute to ${destination}`);\r\n            return;\r\n        }\r\n        for (let value of ret) {\r\n            allowedRooms[value.room] = true;\r\n        }\r\n        return allowedRooms;\r\n    }\r\n    /**\r\n     * check how many rooms were included in a route returned by findRoute\r\n     * @param origin\r\n     * @param destination\r\n     * @returns {number}\r\n     */\r\n    static routeDistance(origin, destination) {\r\n        let linearDistance = Game.map.getRoomLinearDistance(origin, destination);\r\n        if (linearDistance >= 32) {\r\n            return linearDistance;\r\n        }\r\n        let allowedRooms = this.findRoute(origin, destination);\r\n        if (allowedRooms) {\r\n            return Object.keys(allowedRooms).length;\r\n        }\r\n    }\r\n    /**\r\n     * build a cost matrix based on structures in the room. Will be cached for more than one tick. Requires vision.\r\n     * @param room\r\n     * @param freshMatrix\r\n     * @returns {any}\r\n     */\r\n    static getStructureMatrix(room, freshMatrix) {\r\n        if (!this.structureMatrixCache[room.name] || (freshMatrix && Game.time !== this.structureMatrixTick)) {\r\n            this.structureMatrixTick = Game.time;\r\n            let matrix = new PathFinder.CostMatrix();\r\n            this.structureMatrixCache[room.name] = Traveler.addStructuresToMatrix(room, matrix, 1);\r\n        }\r\n        return this.structureMatrixCache[room.name];\r\n    }\r\n    /**\r\n     * build a cost matrix based on creeps and structures in the room. Will be cached for one tick. Requires vision.\r\n     * @param room\r\n     * @returns {any}\r\n     */\r\n    static getCreepMatrix(room) {\r\n        if (!this.creepMatrixCache[room.name] || Game.time !== this.creepMatrixTick) {\r\n            this.creepMatrixTick = Game.time;\r\n            this.creepMatrixCache[room.name] = Traveler.addCreepsToMatrix(room, this.getStructureMatrix(room, true).clone());\r\n        }\r\n        return this.creepMatrixCache[room.name];\r\n    }\r\n    /**\r\n     * add structures to matrix so that impassible structures can be avoided and roads given a lower cost\r\n     * @param room\r\n     * @param matrix\r\n     * @param roadCost\r\n     * @returns {CostMatrix}\r\n     */\r\n    static addStructuresToMatrix(room, matrix, roadCost) {\r\n        let impassibleStructures = [];\r\n        for (let structure of room.find(FIND_STRUCTURES)) {\r\n            if (structure instanceof StructureRampart) {\r\n                if (!structure.my && !structure.isPublic) {\r\n                    impassibleStructures.push(structure);\r\n                }\r\n            }\r\n            else if (structure instanceof StructureRoad) {\r\n                matrix.set(structure.pos.x, structure.pos.y, roadCost);\r\n            }\r\n            else if (structure instanceof StructureContainer) {\r\n                matrix.set(structure.pos.x, structure.pos.y, 5);\r\n            }\r\n            else {\r\n                impassibleStructures.push(structure);\r\n            }\r\n        }\r\n        for (let site of room.find(FIND_MY_CONSTRUCTION_SITES)) {\r\n            if (site.structureType === STRUCTURE_CONTAINER || site.structureType === STRUCTURE_ROAD\r\n                || site.structureType === STRUCTURE_RAMPART) {\r\n                continue;\r\n            }\r\n            matrix.set(site.pos.x, site.pos.y, 0xff);\r\n        }\r\n        for (let structure of impassibleStructures) {\r\n            matrix.set(structure.pos.x, structure.pos.y, 0xff);\r\n        }\r\n        return matrix;\r\n    }\r\n    /**\r\n     * add creeps to matrix so that they will be avoided by other creeps\r\n     * @param room\r\n     * @param matrix\r\n     * @returns {CostMatrix}\r\n     */\r\n    static addCreepsToMatrix(room, matrix) {\r\n        room.find(FIND_CREEPS).forEach((creep) => matrix.set(creep.pos.x, creep.pos.y, 0xff));\r\n        return matrix;\r\n    }\r\n    /**\r\n     * serialize a path, traveler style. Returns a string of directions.\r\n     * @param startPos\r\n     * @param path\r\n     * @param color\r\n     * @returns {string}\r\n     */\r\n    static serializePath(startPos, path, color = \"orange\") {\r\n        let serializedPath = \"\";\r\n        let lastPosition = startPos;\r\n        this.circle(startPos, color);\r\n        for (let position of path) {\r\n            if (position.roomName === lastPosition.roomName) {\r\n                new RoomVisual(position.roomName)\r\n                    .line(position, lastPosition, { color: color, lineStyle: \"dashed\" });\r\n                serializedPath += lastPosition.getDirectionTo(position);\r\n            }\r\n            lastPosition = position;\r\n        }\r\n        return serializedPath;\r\n    }\r\n    /**\r\n     * returns a position at a direction relative to origin\r\n     * @param origin\r\n     * @param direction\r\n     * @returns {RoomPosition}\r\n     */\r\n    static positionAtDirection(origin, direction) {\r\n        let offsetX = [0, 0, 1, 1, 1, 0, -1, -1, -1];\r\n        let offsetY = [0, -1, -1, 0, 1, 1, 1, 0, -1];\r\n        let x = origin.x + offsetX[direction];\r\n        let y = origin.y + offsetY[direction];\r\n        if (x > 49 || x < 0 || y > 49 || y < 0) {\r\n            return;\r\n        }\r\n        return new RoomPosition(x, y, origin.roomName);\r\n    }\r\n    /**\r\n     * convert room avoidance memory from the old pattern to the one currently used\r\n     * @param cleanup\r\n     */\r\n    static patchMemory(cleanup = false) {\r\n        if (!Memory.empire) {\r\n            return;\r\n        }\r\n        if (!Memory.empire.hostileRooms) {\r\n            return;\r\n        }\r\n        let count = 0;\r\n        for (let roomName in Memory.empire.hostileRooms) {\r\n            if (Memory.empire.hostileRooms[roomName]) {\r\n                if (!Memory.rooms[roomName]) {\r\n                    Memory.rooms[roomName] = {};\r\n                }\r\n                Memory.rooms[roomName].avoid = 1;\r\n                count++;\r\n            }\r\n            if (cleanup) {\r\n                delete Memory.empire.hostileRooms[roomName];\r\n            }\r\n        }\r\n        if (cleanup) {\r\n            delete Memory.empire.hostileRooms;\r\n        }\r\n        console.log(`TRAVELER: room avoidance data patched for ${count} rooms`);\r\n    }\r\n    static deserializeState(travelData, destination) {\r\n        let state = {};\r\n        if (travelData.state) {\r\n            state.lastCoord = { x: travelData.state[STATE_PREV_X], y: travelData.state[STATE_PREV_Y] };\r\n            state.cpu = travelData.state[STATE_CPU];\r\n            state.stuckCount = travelData.state[STATE_STUCK];\r\n            state.destination = new RoomPosition(travelData.state[STATE_DEST_X], travelData.state[STATE_DEST_Y], travelData.state[STATE_DEST_ROOMNAME]);\r\n        }\r\n        else {\r\n            state.cpu = 0;\r\n            state.destination = destination;\r\n        }\r\n        return state;\r\n    }\r\n    static serializeState(creep, destination, state, travelData) {\r\n        travelData.state = [creep.pos.x, creep.pos.y, state.stuckCount, state.cpu, destination.x, destination.y,\r\n            destination.roomName];\r\n    }\r\n    static isStuck(creep, state) {\r\n        let stuck = false;\r\n        if (state.lastCoord !== undefined) {\r\n            if (this.sameCoord(creep.pos, state.lastCoord)) {\r\n                // didn't move\r\n                stuck = true;\r\n            }\r\n            else if (this.isExit(creep.pos) && this.isExit(state.lastCoord)) {\r\n                // moved against exit\r\n                stuck = true;\r\n            }\r\n        }\r\n        return stuck;\r\n    }\r\n}\r\nTraveler.structureMatrixCache = {};\r\nTraveler.creepMatrixCache = {};\r\n// this might be higher than you wish, setting it lower is a great way to diagnose creep behavior issues. When creeps\r\n// need to repath to often or they aren't finding valid paths, it can sometimes point to problems elsewhere in your code\r\nconst REPORT_CPU_THRESHOLD = 1000;\r\nconst DEFAULT_MAXOPS = 20000;\r\nconst DEFAULT_STUCK_VALUE = 2;\r\nconst STATE_PREV_X = 0;\r\nconst STATE_PREV_Y = 1;\r\nconst STATE_STUCK = 2;\r\nconst STATE_CPU = 3;\r\nconst STATE_DEST_X = 4;\r\nconst STATE_DEST_Y = 5;\r\nconst STATE_DEST_ROOMNAME = 6;\r\n// assigns a function to Creep.prototype: creep.travelTo(destination)\r\n//# sourceMappingURL=Traveler.js.map","references":[],"map":"{\"version\":3,\"file\":\"Traveler.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/Traveler.ts\"],\"names\":[],\"mappings\":\"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\"}"}
